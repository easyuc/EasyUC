\def\IsDraft{} % set for draft version

\newif\iffull
\fulltrue
%\fullfalse

\documentclass[11pt,letterpaper]{article}

% == Import Packages ==
\usepackage[draft,notes=true,later=false]{dtrt}
\usepackage[margin=1in]{geometry} % Page dimensions
\usepackage{amssymb,amsfonts,amsmath,amsthm} % Math formulas
\usepackage{dsfont}
\usepackage{xcolor} % Colors
\usepackage{listings} % Listings, for code snippets
\usepackage{hyperref} % Hyperlinks
\usepackage{enumitem}
\usepackage[capitalise]{cleveref} % Clever References, must be loaded AFTER all other packages

% == Formatting ==
\renewcommand{\emph}[1]{\textbf{#1}~}
\newcommand{\doclearpage}{%
  \iffull\clearpage\else\fi
}

% == Inline comments ==
\ifdefined\IsDraft
\newcommand{\authnote}[2]{[{\color{red}\textbf{#1:}}~{\color{blue} #2}]}
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\alley}[1]{\authnote{Alley}{#1}}
\newcommand{\megan}[1]{\authnote{Megan}{#1}}
\newcommand{\mayank}[1]{\authnote{Mayank}{#1}}
\newcommand{\ran}[1]{\authnote{Ran}{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREMS
\theoremstyle{plain} % italics
\newtheorem{itheorem}{Theorem}%[section]
\newtheorem{idefinition}{Definition}%[section]
\newtheorem{icorollary}{Corollary}%[section]
\newtheorem{ilemma}{Lemma}%[section]
\iffull
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}[theorem]{Definition}
\fi
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{assumption}{Assumption}
\newtheorem{observation}[theorem]{Observation}

\theoremstyle{definition} % not italics
\newtheorem{construction}[theorem]{Construction}
\iffull
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark} %
\newtheorem{case}{Case}
\fi
\newtheorem{fact}[theorem]{Fact}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% == Code snippets ==
% Listings package docs: http://texdoc.net/texmf-dist/doc/latex/listings/listings.pdf

\lstdefinelanguage{easycrypt}{
	morekeywords={lemma, module, proc, var, return, if, else, require, import, type, op, axiom, pred, section, local, match, with}
}

\renewcommand*{\lstlistingname}{Code Example}

% Define easycrypt environment
\lstnewenvironment{easycrypt}[1][]
{
	\noindent
	\minipage{\linewidth}
	\vspace{0.5\baselineskip}
	\lstset{ % Set inline code parameter(s)
	  basicstyle=\small,						% print whole listing small
	  keywordstyle=\color{black}\bfseries,		% bold black keywords
	  identifierstyle=, 						% nothing happens
	  stringstyle=\ttfamily, 					% typewriter type for strings
	  showstringspaces=false,					% no special string spaces
	  tabsize=2,								% tabs typeset as 2 spaces
	  frame=single,								% lines above and below code snippets
	  breaklines=true,							% break lines when there's overflow
	  language=easycrypt,
	  morecomment=[n][\color{gray}]{(*}{*)},	% define normal comment delimiters, prints gray
	  escapeinside={/*}{*/},					% special delimiters for referencing line numbers
	  literate={~} {$\sim$}{1},					% prettier tilde
	  captionpos=b,								% caption position is bottom
	  numbers=left,								% print line numbers on the left
	  #1										% other custom parameters
	}
}{\endminipage}

% % help cref
\crefname{listing}{Code example}{Code examples} % upper case, personal preference
\Crefname{listing}{Code example}{Code examples}

\newcommand{\code}[1]{\texttt{#1}} % inline code

% == Math ==
% operators
\newcommand{\Or}{\vee}
\renewcommand{\And}{\wedge}
\DeclareMathOperator{\Concat}{\; || \; }
\newcommand{\Union}{\cup}
\newcommand{\LDE}[1]{\hat{#1}}
\newcommand{\RLDE}[1]{\bar{#1}}
\newcommand{\iseq}{\overset{?}{=}}
\newcommand{\eqdef}{\ {:=} \ }
\newcommand{\ip}[2]{\langle #1 , #2 \rangle}
\newcommand{\Time}[1]{\mathrm{time}(#1)}


% == Messages ==
\newcommand{\OpenMsg}{\mathsf{Open}}
\newcommand{\CommitMsg}{\mathsf{Commit}}
\newcommand{\real}{\mathsf{real}}
\newcommand{\obliv}{\mathsf{obliv}}
\newcommand{\Input}{x}

\newcommand{\SecParam}{\lambda}

% PKE
\newcommand{\PKE}{\mathsf{PKE}}
\newcommand{\Gen}{\mathsf{Gen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\OblivEnc}{\mathsf{OblivEnc}}
\newcommand{\OblivEncInv}{\mathsf{OblivEncInv}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\Indcpa}{\mathsf{INDCPA}}
\newcommand{\IndcpaGM}{\mathcal{C}} % the game master (i.e. challenger) for the indcpa game.
\newcommand{\IndcpaAdversary}{{\Adversary_\Indcpa}}
\newcommand{\EncKey}{\mathsf{ek}}
\newcommand{\DecKey}{\mathsf{dk}}
\newcommand{\GuessBit}{b'}
\newcommand{\ChallengerBit}{b}
\newcommand{\ExtBit}{b^*}
\newcommand{\AdvBit}{\Adv{b}}
\newcommand{\EncOracle}{\mathsf{EO}}
\newcommand{\DecOracle}{\mathsf{DO}}
\newcommand{\Msg}{m}
\newcommand{\Ct}{\mathsf{ct}}
\newcommand{\Rand}{r}
\newcommand{\FakeRand}{r_{\mathsf{fake}}}
\newcommand{\Distribution}{\mathcal{D}}
\newcommand{\RandSpace}{\mathcal{R}}

% CFPTP
\newcommand{\CFPTP}{\mathsf{CFPTP}}
\newcommand{\Forw}{\mathsf{Forw}}
\newcommand{\Back}{\mathsf{Back}}
\newcommand{\ForwKey}{\mathsf{fk}}
\newcommand{\BackKey}{\mathsf{bk}}
\newcommand{\Domain}{D}
\newcommand{\CFPTPAdversary}{{\Adversary_\CFPTP}}
\newcommand{\CFPTPInput}{\Input}
\newcommand{\Output}{y}
\newcommand{\CFPTPBit}{b}

% == Proof ==
% UC
\newcommand{\Simulator}{{\mathsf{Sim}}} % Simulator
\newcommand{\Adversary}{{\mathsf{Adv}}} % Adversary
\newcommand{\Adv}[1]{\tilde{#1}} % For adversarially generated values
\newcommand{\AdversaryB}{{\mathsf{B}}} % Adversary
\newcommand{\Environment}{{\mathcal{Z}}} % Environment
\newcommand{\IF}{\mathcal{F}} % Ideal functionality
\newcommand{\sid}{\mathsf{sid}}

% Hybrids
\newcommand{\Ideal}{{\mathsf{IDEAL}}}
\newcommand{\Hyb}{{\mathsf{HYB}}}
\newcommand{\Real}{{\mathsf{REAL}}}
\newcommand{\bad}{{\mathsf{bad}}}
\newcommand{\True}{\mathsf{true}}
\newcommand{\False}{\mathsf{false}}
\newcommand{\G}{\mathsf{G}}

\newcommand{\pST}{\; \middle| \;}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\negl}{\mathrm{negl}}
\newcommand{\Bits}{\{0,1\}}
\newcommand{\Naturals}{\mathbb{N}}
\newcommand{\Reals}{\mathbb{R}}
\newcommand{\Integers}{\mathbb{Z}}

% CRS
\newcommand{\IFCrs}{\IF_{\mathrm{CRS}}}
\newcommand{\CrsDistr}{\mathcal{D}}
\newcommand{\crs}{\mathsf{crs}}

% Commitment
\newcommand{\IFCom}{\IF_{\mathrm{COM}}}
\newcommand{\IFMcom}{\IF_{\mathrm{MCOM}}}
\newcommand{\Party}{\mathrm{P}}
\newcommand{\PartyCommitter}{\mathrm{C}}
\newcommand{\PartyVerifier}{\mathrm{V}}
\newcommand{\CommittedBit}{b}

% Files
\newcommand{\File}[1]{\texttt{#1}}

% Cramer-Shoup
\newcommand{\Group}{\mathbb{G}}
\newcommand{\GrpOrd}{q}
\newcommand{\GrpEltC}{c}
\newcommand{\GrpEltD}{d}
\newcommand{\GrpEltE}{e}
\newcommand{\GrpEltH}{h}
\newcommand{\GrpEltU}{u}
\newcommand{\GrpEltV}{v}
\newcommand{\Generator}{g}
\newcommand{\Hash}{H}
\newcommand{\ExpX}{x}
\newcommand{\ExpY}{y}
\newcommand{\ExpZ}{z}
\newcommand{\Tag}{\alpha}

% == Document title ==
\title{\cite{CanettiF01} adaptive security proof}
\author{Megan Chen}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\doclearpage
\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Claw-free pair of trapdoor permutations (CFPTP)}
A \emph{claw-free pair of trapdoor permutations} over a domain $\Domain$ is defined as $\CFPTP = (\Gen, \Forw, \Back, \Dec)$, such that:
\begin{itemize}
	\item $\Gen(1^\SecParam)$: On input a security parameter $1^\SecParam$, outputs a forward key $\ForwKey$ and backward key $\BackKey$.
	\item $\Forw_{\CFPTPBit, \ForwKey}(\CFPTPInput)$: On input a bit $\CFPTPBit$, a forward key $\ForwKey$ and a value $\Input \in \Domain$, outputs the result $\Output \in \Domain$ of running permutation $\CFPTPBit$ forwards.
	\item $\Back_{\CFPTPBit, \BackKey}(\Output)$: On input a bit $\CFPTPBit$, a backward key $\BackKey$ and a value $\Output \in \Domain$, outputs the result $\Input \in \Domain$ of running permutation $b$ backwards.
\end{itemize}
We require that $\CFPTP$ is claw-free: given only $\ForwKey$, it is hard to find $\CFPTPInput_0, \CFPTPInput_1$ such that $\Forw_{\CFPTPBit, \ForwKey}(\CFPTPInput_0) = \Forw_{\CFPTPBit, \ForwKey}(\CFPTPInput_1)$

\subsection{Public key encryption (PKE)}

A \emph{public key encryption scheme} $\PKE = (\Gen, \Enc, \Dec)$ works as follows:
\begin{itemize}
	\item $\Gen(1^\SecParam)$: On input a security parameter $1^\SecParam$, outputs an encryption key $\EncKey$ and decryption key $\DecKey$.
	\item $\Enc(\EncKey,\Msg)$: On input an encryption key $\EncKey$ and message $\Msg$, outputs an encryption of message $\Msg$.
	\item $\Dec_{\DecKey}(\Ct)$: On input a decryption key $\DecKey$ and ciphertext $\Ct$, outputs the decrypton of a ciphertext $\Ct$.
\end{itemize}

$\PKE$ satisfies the following properties:
\begin{itemize}
    \item \emph{Correctness.} For all keys $(\EncKey, \DecKey) \gets \Gen(1^{\SecParam})$ and messages $\Msg$, we have
    \[ \Pr[ \Dec_{\DecKey} (\Enc_{\EncKey} (\Msg)) = \Msg ] = 1. \]

    \item \emph{Obliviously-sampleable.} There additionally exist algorithms $(\OblivEnc, \OblivEncInv)$ with the following syntax:
    \begin{itemize}
    	\item $\OblivEnc(\EncKey,\Rand)$: On input the encryption key $\EncKey$ and randomness $\Rand$, outputs a ciphertext $\Ct$.
    	\item $\OblivEncInv(\EncKey,\Ct)$: On input the encryption key $\EncKey$ and a ciphertext $\Ct$, outputs randomness $\FakeRand$.
    \end{itemize}

    Further, we call the following distinguishing game the \textbf{oblivious Ind-CCA2 game}: for any stateful adversary $\Adversary$, the following distributions are negligibly-close:
    \begin{align*}
		&\Distribution_0(\SecParam) \eqdef \left\{
		(\Ct,\Rand)
		\pST
		\begin{array}{r}
            (\EncKey,\DecKey)\gets \Gen(1^\SecParam)\\
			\Msg \gets \Adversary(\EncKey)\\
            \Rand \gets \RandSpace\\
			\Ct \eqdef \Enc(\EncKey,\Msg;\Rand)\\
		\end{array}
		\right\} \\
		&\text{and } \Distribution_1(\SecParam) \eqdef \left\{
		(\Ct, \Rand)
		\pST
		\begin{array}{r}
            (\EncKey,\DecKey)\gets \Gen(1^\SecParam)\\
            \Msg \gets \Adversary(\EncKey)\\
            \Rand \gets \RandSpace\\
            \Ct \gets \OblivEnc(\EncKey,\Rand)\\
		\end{array}
		\right\} \enspace.
	\end{align*}
\end{itemize}

% \begin{lemma}
%     Let $\PKE = (\Gen, \Enc, \Dec, \OblivEnc, \OblivEncInv)$ be an obliviously-sampleable CCA-secure public key encryption scheme and $\SecParam\in\Naturals$ be a security parameter. Then for all adversaries $\Adversary$,
%     \begin{equation}
%     \label{eqn:prod-msg-rand}
%         \Pr \left[
%             \Enc(\EncKey,\Msg';\Rand') = \Ct
%         \pST
%         \begin{array}{r}
%             (\EncKey,\DecKey) \gets \Gen(1^{\SecParam})\\
%             \Rand \gets \RandSpace\\
%             \Ct \gets \OblivEnc(\EncKey, \Rand)\\
%             (\Msg',\Rand') \gets \Adversary(\Ct)\\
%         \end{array}
%         \right] = \negl(\SecParam).
%     \end{equation}
% \end{lemma}
%
% \begin{proof}
%     Suppose there exists an adversary $\Adversary$ who satisfies the probability in \Cref{eqn:prod-msg-rand} with probability $\delta$. We argue via reduction that this implies breaking the oblivious-sampleability property of $\PKE$.
%
%     Construct a (stateful) adversary $\AdversaryB$ that breaks the oblivious-sampleabilty of $\PKE$ as follows:
%     \begin{itemize}
%         \item \textbf{Message generation.} $\AdversaryB(\EncKey) \to \Msg$
%         \begin{enumerate}[nolistsep]
%             \item Parse $\EncKey$ as the encryption key.
%             \item Output a random $\Msg$.
%         \end{enumerate}
%         \item \textbf{Message generation.} $\AdversaryB(\Ct) \to \GuessBit$
%         \begin{enumerate}[nolistsep]
%             \item Run $(\Msg',\Rand')\gets \Adversary(\Ct)$.
%             \item If $\Msg = \Msg'$, output $\GuessBit = 0$. Otherwise, output $\GuessBit = 1$.
%         \end{enumerate}
%     \end{itemize}
%     By the correctness of $\Adversary$, we have $\Enc(\EncKey, \Msg'; \Rand') = \Ct$ with probability $\delta$.
%
%     \begin{itemize}
%         \item \textbf{Case 1:} Suppose $\Ct$ is from $\Distribution_0$, i.e. $\Ct \eqdef \Enc(\EncKey,\Msg;\Rand)$.
%         \item \textbf{Case 2:} Suppose $\Ct$ is from $\Distribution_1$, i.e. $\Ct \eqdef \OblivEnc(\EncKey,\Rand)$ for some $\Rand \gets \RandSpace$.
%     \end{itemize}
%
%     \megan{Note: For a fixed key pair, cannot have $\Msg \ne \Msg'$ st $\Enc(\EncKey, \Msg, \Rand) = \Enc(\EncKey, \Msg', \Rand')$. Otherwise, we would contradict correctness of the decryption oracle.}
% \end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adaptive chosen-ciphertext attack security (LR-CCA2)}
\label{sec:lr-cca2}
\cite{CanettiF01} uses a left-or-right oracle formulation of security against chosen ciphertext attacks. Let $\SecParam\in\Naturals$ be a security parameter. First, define an encryption-decryption oracle pair $(\EncOracle, \DecOracle)$ with respect to a key pair $(\EncKey,\DecKey) \gets \Gen(1^\SecParam)$ as follows:
\begin{itemize}
	\item Encryption oracle

	\begin{minipage}{0.9\textwidth}
	$\EncOracle(\ChallengerBit,\EncKey):$
	\begin{enumerate}[nolistsep]
		\item \textbf{Init:} Receive a bit $\ChallengerBit$ and an encryption key $\EncKey$.
		\item \textbf{Encryption queries:} Upon receiving a message pair $(\Msg_0, \Msg_1)$, output $\Enc(\EncKey,\Msg_{\ChallengerBit})$.
	\end{enumerate}
	\end{minipage}

	\item Decryption oracle

	\begin{minipage}{0.9\textwidth}
	$\DecOracle(\DecKey):$
	\begin{enumerate}[nolistsep]
		\item \textbf{Init:} Receive a decryption key $\DecKey$.
		\item \textbf{Decryption queries:} Upon receiving a ciphertext $\Ct$, output $\Dec_{\DecKey}(\Ct)$.
	\end{enumerate}
	\end{minipage}
\end{itemize}


A public key encryption scheme $\PKE$ is secure against left-or-right adaptive chosen ciphertext attacks (LR-CCA2) if for any PPT adversary $\Adversary$:

\begin{align*}
	\Pr \left[
	\begin{array}{c}
		\GuessBit = \ChallengerBit
	\end{array}
	\pST
	\begin{array}{r}
		(\EncKey, \DecKey) \gets \Gen(1^{\SecParam})\\
		\ChallengerBit \gets \Bits\\
		\GuessBit \gets \Adversary^{\EncOracle(\ChallengerBit,\EncKey), \DecOracle(\DecKey)}(\EncKey)\\
	\end{array}
	\right] \leq \frac{1}{2} + \frac{1}{\poly(\SecParam)}.
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cramer-Shoup encryption scheme}
\label{sec:cramer-shoup}
We recall the Cramer-Shoup encryption scheme \cite{CramerS98} and argue that it satisfies the definition of an obliviously-sampleable IND-CCA encryption scheme, as modelled in \code{IndCCA.ec}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{The scheme}
\label{sec:cramer-shoup-scheme}

Let $\Group$ be a group of (large) prime order $\GrpOrd > 2^{\SecParam}$. Let $\Hash \colon \Bits^{*} \to \Bits^{\SecParam}$ be a universal one-way hash function.


\newcommand{\GrpEltG}{g}
\newcommand{\MultGrpOrd}{p}
\newcommand{\MultGrp}{\Integers^{\times}_{\MultGrpOrd}}
\newcommand{\OrdW}{w}
\newcommand{\RandStr}{\mu}
\newcommand{\OblivEltGen}{\mathsf{OblivEltGen}}
\newcommand{\Inv}[1]{{#1}^{-1}}
\newcommand{\OblivEltInv}{\Inv{\mathsf{OblivEltGen}}}
Set up the following public values:
\begin{itemize}
\item[] \textbf{Public values:}
\begin{enumerate}[nolistsep]
    \item Select a public value $\OrdW \in \Integers$ such that $\GrpOrd$ does not divide $\OrdW$.
    \item Set $\MultGrpOrd \eqdef \GrpOrd \OrdW + 1$. Note that this implies $\Group \subseteq \MultGrp$ because $\GrpOrd \:|\: \MultGrpOrd - 1$.
\end{enumerate}
\end{itemize}

We define two subroutines used for oblivious sampleability.
First, we describe a method of oblivously sampling an element in the group $\Group$:

\begin{itemize}
\item[]$\OblivEltGen(\RandStr) \to \GrpEltH$.
    \begin{enumerate}[nolistsep]
        %\item Sample a string $\RandStr \gets \Bits^{2 \log_2 (\MultGrpOrd)}$. Cast $\RandStr$ as an element of the multiplicative group $\MultGrp$. %Megan: Comment bc can take the string as input.
        \item Parse $\RandStr$ as an element of $\MultGrp$.
        \item Compute the group element as $\GrpEltH \eqdef \RandStr^{\OrdW} \in \Group \subseteq \MultGrp$.\footnote{This procedure is statistically-close to selecting a random element in $\Group$. \megan{why?}}
        \item Output $\GrpEltH$.
    \end{enumerate}
\end{itemize}

Second, we describe a method of finding a group element's inverse: given $\GrpEltH\in\Group$, find $\Inv{\GrpEltH}$ such that $\left(\Inv{\GrpEltH}\right)^\OrdW = \GrpEltH\in\Group\subseteq\MultGrp$:
\begin{itemize}
\item[]$\OblivEltInv_{\MultGrpOrd}(\GrpEltH) \to \Inv{\GrpEltH}$.
    \begin{enumerate}[nolistsep]
        \item Parse $\GrpEltH$ as an element of $\MultGrp$.
        \item Pick a generator $\Generator \in \MultGrp$.
        \item Find $x$ such that $x\OrdW \equiv 1 \text{ mod } \GrpOrd$.
        \item Sample $i \gets \{0, \ldots, \OrdW-1\}$.
        \item Compute $\Inv{\GrpEltH} \eqdef \GrpEltH^{x}\Generator^{i\GrpOrd} \text{ mod } \MultGrpOrd$. Note that the $\Generator^{i\GrpOrd}$ are the $\OrdW$-th roots of unity.
        \item Output $\Inv{\GrpEltH}$.
    \end{enumerate}
\end{itemize}

Now, we recall the Cramer-Shoup encryption scheme, including the $\OblivEnc$ and $\OblivEncInv$ algorithms that make the scheme obliviously-sampleable \cite{CanettiF01}.
\begin{itemize}[nolistsep]
    \item \textbf{Key generation:} $\Gen(1^{\SecParam}) \to (\EncKey, \DecKey)$.
    \begin{enumerate}[nolistsep]
        \item Pick two generators $\Generator_1, \Generator_2$ of the group $\Group$.
        \item Pick $\ExpX_1, \ExpX_2, \ExpY_1, \ExpY_2, \ExpZ \gets \Integers_{\GrpOrd}$.
        \item Compute the group elements $\GrpEltC \eqdef \Generator_1^{\ExpX_1}\Generator_2^{\ExpX_2}, \GrpEltD \eqdef \Generator_1^{\ExpY_1}\Generator_2^{\ExpY_2}$, and $\GrpEltH \eqdef \Generator_1^{\ExpZ}$.
        \item Pick randomness $\Rand \gets \Integers_{\GrpOrd}$.
        \item Output
        \begin{equation*}
            \EncKey \eqdef (\Generator_1, \Generator_2, \GrpEltC, \GrpEltD, \GrpEltH, \Hash)
            \textrm{ and }
            \DecKey \eqdef (\ExpX_1, \ExpX_2, \ExpY_1, \ExpY_2, \ExpZ)
            \enspace.
        \end{equation*}
    \end{enumerate}

    \item \textbf{Encryption:} $\Enc(\EncKey, \Msg, \Rand) \to \Ct$.
    \begin{enumerate}[nolistsep]
        \item Parse the encryption key $\EncKey = (\Generator_1 \in \Group, \Generator_2 \in \Group, \GrpEltC\in \Group, \GrpEltD\in \Group, \GrpEltH\in \Group, \Hash \colon \Bits^{*} \to \Bits^{\SecParam})$, the message $\Msg \in \Group$, and randomness $\Rand \in \Integers_{\GrpOrd}$.
        \item Compute
        \begin{align*}
            \GrpEltU_1 &\eqdef \Generator_1^{\Rand}\\
            \GrpEltU_2 &\eqdef \Generator_2^{\Rand}\\
            \GrpEltE &\eqdef \GrpEltH^{\Rand}\Msg\\
            \Tag &\eqdef \Hash(\GrpEltU_1, \GrpEltU_2, \GrpEltE)\\
            \GrpEltV &\eqdef \GrpEltC^{\Rand}\GrpEltD^{\Rand\Tag}
            \enspace.
        \end{align*}
        \item Output the ciphertext $\Ct \eqdef (\GrpEltU_1, \GrpEltU_2, \GrpEltE, \GrpEltV)$.
    \end{enumerate}

    \item \textbf{Decryption:} $\Dec(\DecKey, \Ct) \to \Msg$.
    \begin{enumerate}[nolistsep]
        \item Parse the decryption key $\DecKey = (\ExpX_1, \ExpX_2, \ExpY_1, \ExpY_2, \ExpZ) \in \Integers_{\GrpOrd}^5$, and the ciphertext $\Ct = (\GrpEltU_1, \GrpEltU_2, \GrpEltE, \GrpEltV) \in \Group^4$.
        \item Compute $\Tag = \Hash(\GrpEltU_1, \GrpEltU_2, \GrpEltE)$.
        \item Check if
        \begin{equation*}
            \GrpEltU_1^{\ExpX_1 + \ExpY_1 \Tag} \GrpEltU_2^{\ExpX_2 + \ExpY_2 \Tag} = \GrpEltV
            \enspace.
        \end{equation*} If so, output $\Msg = \GrpEltE / \GrpEltU_1^{\ExpZ}$. Otherwise, output $\bot$.
    \end{enumerate}

    \item \textbf{Obliviously-sampled ciphertext:} $\OblivEnc(\EncKey, \Rand) \to \Ct$.
    \begin{enumerate}[nolistsep]
        \item Parse $\Rand = (\RandStr_{\GrpEltU_1}, \RandStr_{\GrpEltU_2}, \RandStr_{\GrpEltE}, \RandStr_{\GrpEltV})$.
        \item Run
        \begin{align*}
            &\GrpEltU_1 \gets \OblivEltGen( \RandStr_{\GrpEltU_1})\\
            &\GrpEltU_2 \gets \OblivEltGen( \RandStr_{\GrpEltU_2})\\
            &\GrpEltE \gets \OblivEltGen( \RandStr_{\GrpEltE})\\
            &\GrpEltV \gets \OblivEltGen( \RandStr_{\GrpEltV})
            \enspace.
        \end{align*}
        \item Output $\Ct \eqdef (\GrpEltU_1,\GrpEltU_2,\GrpEltE,\GrpEltV)$.
    \end{enumerate}

    \item \textbf{Obliviously-sampled randomness:} $\OblivEncInv(\EncKey, \Ct) \to \Rand$.
    \begin{enumerate}[nolistsep]
        \item Parse $\EncKey$ as the encryption key and $\Ct = (\GrpEltU_1,\GrpEltU_2,\GrpEltE,\GrpEltV)$.
        \item Run
        \begin{align*}
            &\Inv{\GrpEltU_1} \gets \OblivEltInv_{\MultGrpOrd}(\GrpEltU_1)\\
            &\Inv{\GrpEltU_2} \gets \OblivEltInv_{\MultGrpOrd}(\GrpEltU_2)\\
            &\Inv{\GrpEltE} \gets \OblivEltInv_{\MultGrpOrd}(\GrpEltE)\\
            &\Inv{\GrpEltV} \gets \OblivEltInv_{\MultGrpOrd}(\GrpEltV)
            \enspace.
        \end{align*}
        \item Output $\Rand \eqdef (\Inv{\GrpEltU_1}, \Inv{\GrpEltU_2}, \Inv{\GrpEltE}, \Inv{\GrpEltV})$.
    \end{enumerate}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\code{IndCCA.ec} validation}
\label{sec:indcca-model-validation}

We justify our modeling of an obliviously-sampleable IND-CCA encryption scheme by arguing that Cramer-Shoup satisfies the axioms listed in \code{IndCCA.ec}.

\renewcommand{\mod}{\textrm{ mod }}
\begin{itemize}
% \item \textbf{Plaintext space:} $\Group$.
% \item \textbf{Randomness space:} $\Rand\gets\Integers_{\GrpOrd}$.
% \item \textbf{Ciphertext space:} $\Group^{4}$.
\item \textbf{\code{axiom correctness}:} This is the standard correctness property of encryption schemes.
\item \textbf{\code{axiom dec\_suceeds}:} \megan{\code{.ec} file has a note that this isn't required for our proofs.}
\item \textbf{\code{lemma dec\_fails}:} \megan{todo}
\item \textbf{\code{axiom obliv\_enc\_cancel}:}

This axiom is \textbf{\color{red}false}. Below is a counterexample to show that sometimes $\OblivEltInv_{\MultGrpOrd}(\OblivEltGen(\RandStr)) \ne \RandStr$:
\begin{itemize}[nolistsep]
    \item Set $\MultGrpOrd = 7$, $\OrdW = 2$, $\GrpOrd = 3$, and $x = 2$. Notes:
    \begin{itemize}[nolistsep]
        \item These parameters correspond to defining the subgroup $\Group \subset \MultGrp$ so that $\Group \eqdef (\{1,2,4\}, \cdot \mod 7)$. %the set $\{1,2,4\}$ with operation multiplication modulo $7$.
        \item The generators of $\MultGrp$ are $\{3,5\}$.
    \end{itemize}

    \item Let $\RandStr = 5$. Then $\OblivEltGen(5) = \RandStr^{\OrdW} = 25 \equiv 4 \mod 7$. So $\GrpEltH = 4$.
    \item Suppose $\OblivEltInv_{7}(\GrpEltH)$ selects the (randomly) the choices $\Generator=3$, $x = 2$, $i = 2$. Then
    \begin{align*}
    \OblivEltInv_{7}(\GrpEltH) = \GrpEltH^{x}\Generator^{i\GrpOrd} = 4^2 \cdot 3^{2 \cdot 3} = 16 \cdot 729 \equiv 2 \mod 7
    \enspace.
    \end{align*}
    Thus $\Inv{\GrpEltH} = 2 \ne 5 = \RandStr$. (Still, $2^{\OrdW} = 2^2 = 4 \mod 7$.)

    Moreover, if we combine the above with the definitions of $\OblivEncInv$ and $\OblivEnc$, we get
    \begin{equation*}
    \Pr\left[\OblivEncInv(\EncKey, \OblivEnc(\EncKey, \Rand)) = \Rand\right] \ne 1
    \enspace.
    \end{equation*}
    (Note that the encryption key $\EncKey$ does not play a role in either $\OblivEnc$ or $\OblivEncInv$.)
\end{itemize}

\item \textbf{\code{axiom obliv\_enc\_inv\_cancel}:} \megan{I think this one is true because $\OblivEltInv$ outputs $\Inv{\GrpEltH}$ such that $(\Inv{\GrpEltH})^{\OrdW} = \GrpEltH$.}

\item \textbf{\code{axiom mu\_obliv\_enc\_dec\_exact\_ub}:} \megan{I forgot how to parse this easycrypt, but I think it's related to the ratio computed in the below item.}

\item \textbf{Ratio of real and oblivously-sampled ciphertext space sizes}
\begin{itemize}[nolistsep]
    \item A real ciphertext is $(\Ct_1,\Ct_2,\Ct_3,\Ct_4) \in \Group^4$. Given $\EncKey \eqdef (\Generator_1, \Generator_2, \GrpEltC, \GrpEltD, \GrpEltH, \Hash)$, there are $q$ choices for $\Ct_1$. Fixing $\Ct_1$ this also fixes an $\Rand \mod \GrpOrd$ such that $\Ct_1 = \Generator_1^r$, $\Ct_2 = \Generator_2^r$, and $\Ct_3 = \GrpEltH^r\cdot \Msg$, where $\Msg$ is the input message. Further $\Tag = \Hash(\Ct_1, \Ct_2, \Ct_3)$ outputs a fixed value given $(\Ct_1, \Ct_2, \Ct_3)$, so the value of $\Ct_4$ is also fixed. Thus there are at most $\GrpOrd$ valid ciphertexts given $\EncKey$ and $\Msg$.

    \item The number of possible of obliviously-sampled ciphertexts is $\GrpOrd^4$, since we can view each element of the ciphertext string as uniformly random in $\Group$.

    \item Thus, the ratio of the number of real ciphertexts to the number of possible oblivously-sampled ciphertexts is $\frac{1}{\GrpOrd^3} = \frac{1}{2^{3\cdot\SecParam}}$.
\end{itemize}

\end{itemize}

\megan{finish}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\doclearpage
\section{Ideal functionalities}
\label{sec:ideal-functionalities}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{CRS}
\label{sec:ideal-func-crs}
$\IFCrs$ is exactly as in Figure 1 of \cite{CanettiF01}, except that the CRS distribution $\CrsDistr$ is sampled as follows:
\begin{enumerate}[nolistsep]
	\item $(\ForwKey,\BackKey) \gets \CFPTP.\Gen(1^{\SecParam})$.
	\item $(\EncKey,\DecKey) \gets \PKE.\Gen(1^{\SecParam})$.
	\item Set the CRS value $\crs \eqdef (\ForwKey, \EncKey)$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Single-session commitment, adaptive}
\label{sec:ideal-func-com}

\megan{wip}
We define an ideal functionality for single-session commitments that allows adaptive corruptions and mirrors what is in \File{Commitment.uc}.
\newcommand{\EnvCommitReqMsg}{\mathsf{EnvCommitReq}}
\newcommand{\IFCommitReqMsg}{\mathsf{IFCommitReq}}
\newcommand{\SimCommitterCorruptionStatusMsg}{\mathsf{CommitterCorruptionStatus}}
\newcommand{\CommitterBitMsg}{\mathsf{CommitterBit}}
\newcommand{\CommitterCorruptedBit}{\mathsf{corrupted}}
\newcommand{\CommitOkMsg}{\mathsf{CommitOk}}

$\IFCom:$
\begin{enumerate}
	\item \textbf{Activation.} Receive $(\EnvCommitReqMsg, \sid, \PartyCommitter, \PartyVerifier, \CommittedBit)$ from $\Environment$, and send $(\IFCommitReqMsg, \sid, \PartyCommitter,\PartyVerifier)$ to $\Simulator$.

	\item \textbf{Initial corruption sequence.} Receive $(\SimCommitterCorruptionStatusMsg, \CommitterCorruptedBit)$ from $\Simulator$.
	\begin{itemize}
		\item If $\CommitterCorruptedBit = \True$, send $(\CommitterBitMsg, \CommittedBit)$ to $\Simulator$.
		\item If $\CommitterCorruptedBit = \False$, send $(\CommitterBitMsg, \bot)$ to $\Simulator$.
	\end{itemize}

	\item \textbf{Commit.} Receive $(\CommitOkMsg)$ from $\Simulator$ and send $(\CommitMsg, \sid, \PartyCommitter, \PartyVerifier)$ to $\PartyVerifier$.

	\item \textbf{Open.} \megan{TODO}

	\item \textbf{Corruption.} Receive $(\EnvCommitReqMsg, \sid, \PartyCommitter, \PartyVerifier, \CommittedBit)$ from $\Environment$. Send $(\IFCommitReqMsg, \sid, \PartyCommitter,\PartyVerifier, \CommittedBit)$ to $\Simulator$.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\doclearpage
\section{Hybrids for adaptive security}
\label{sec:hybrids-adaptive}

\newcommand{\CommitterId}{\mathsf{cid}}
\newcommand{\ReceiverId}{\mathsf{rid}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Real}
\label{sec:real-distr}

The committer does the following:
\begin{itemize}
\item \parhead{Commit round}
\begin{enumerate}[nolistsep]
	\item Receive $(\CommitMsg,\sid,\CommitterId,\ReceiverId,\CommittedBit)$ from $\Environment$.
	\item Query $\IFCrs$ to get the common reference string $\crs = (\ForwKey, \EncKey)$.
	\item Sample $\Input \gets \Domain$.
	\item Sample commitment randomness $\Rand_{\CommittedBit}$ and $\Rand_{1-\CommittedBit}$.
	\item Compute $\Output = \CFPTP.\Forw_{\CommittedBit, \ForwKey}(\Input)$.
	\item Compute $\Ct_{\CommittedBit} = \PKE.\Enc_\EncKey(\sid,\Input; \Rand_\CommittedBit)$.
	\item Compute $\Ct_{1-\CommittedBit} = \PKE.\OblivEnc_\EncKey(\Rand_{1-\CommittedBit})$.
	\item Send $(\sid,\CommitterId,\ReceiverId,\Output, \Ct_0, \Ct_1)$.
\end{enumerate}

\item \parhead{Open round}
\begin{enumerate}[nolistsep]
    \item Receive $(\OpenMsg,\sid,\CommitterId,\ReceiverId)$ from $\Environment$.
    \item Send $(\sid,\CommitterId,\ReceiverId,\CommittedBit, \Input, \Rand_{\CommittedBit})$.
\end{enumerate}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hybrid}
\label{sec:hyb-distr}

\megan{this section wip}
\parhead{Case 1: Honest commit message}
The (hybrid) simulator $\Simulator$ does the following:
\begin{itemize}
\item \parhead{Simulate $\IFCrs$}
\begin{enumerate}[nolistsep]
    \item Generate encryption keys: $(\EncKey, \DecKey) \gets \PKE.\Gen(1^{\SecParam})$.
    \item Generate CFPTP keys: $(\ForwKey,\BackKey) \gets \CFPTP.\Gen(1^{\SecParam})$.
    \item Define the CRS string $\crs = (\ForwKey, \EncKey)$.
    \item If $\Simulator$ receives any queries to $\IFCrs$, return the CRS string $\crs = (\ForwKey, \EncKey)$.
\end{enumerate}

\item \parhead{Commit round}
\begin{enumerate}[nolistsep]
    \item Query $\Environment$ to get the actual committed bit $\CommittedBit$ from $\IFCom$. \megan{check if this is legal}
	\item Sample $\Input \gets \Domain$.
	\item Sample commitment randomness $\Rand_{\CommittedBit}$ and $\Rand_{1-\CommittedBit}$.
	\item Compute $\Output = \CFPTP.\Forw_{\CommittedBit, \ForwKey}(\Input)$.
	\item Compute $\Ct_{\CommittedBit} = \PKE.\Enc_\EncKey(\sid,\Input; \Rand_\CommittedBit)$. Store $(\sid,\Ct_{\CommittedBit},\real)$ in memory.
	\item Compute $\Ct_{1-\CommittedBit} = \PKE.\OblivEnc_\EncKey(\Rand_{1-\CommittedBit})$. Store $(\sid,\Ct_{\CommittedBit},\obliv)$ in memory.
	\item Send $(\sid,\CommitterId,\ReceiverId,\Output, \Ct_0, \Ct_1)$.
\end{enumerate}

\item \parhead{Open round} \megan{todo}
\begin{enumerate}[nolistsep]
\item Receive $(\OpenMsg,\sid,\CommitterId,\ReceiverId)$ from $\Environment$.
\item Send $(\sid,\CommitterId,\ReceiverId,\CommittedBit, \Input, \Rand_{\CommittedBit})$.
\end{enumerate}
\end{itemize}


\parhead{Case 2: Corrupted commit message}
\begin{itemize}
    \item Receive $\Adversary$'s desired commitment string: $(\Adv{\Output}, \Adv{\Ct_0}, \Adv{\Ct_1})$. \footnote{Note that $\Simulator$ must ``forget'' the environment's committed bit $\CommittedBit$ and extract a new committed bit $\ExtBit$ because $\Adversary$'s new commitment string may be arbitrary string or adaptively-generated based on the honest committer's original commitment string $(\Output, \Ct_0, \Ct_1)$.}
    \item If there exists a string $(\sid, \Adv{\Ct_{0}} ,\obliv)$ in memory, set $\ExtBit = 1$.
    \item If there exists a string $(\sid, \Adv{\Ct_{1}} ,\obliv)$ in memory, set $\ExtBit = 0$. \megan{double check}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ideal}
\label{sec:ideal-distr}

\parhead{Case 1: Honest committer}

The simulator $\Simulator$ does the following:
\begin{itemize}
\item \parhead{Simulate $\IFCrs$}
\begin{enumerate}[nolistsep]
    \item Generate encryption keys: $(\EncKey, \DecKey) \gets \PKE.\Gen(1^{\SecParam})$.
    \item Generate CFPTP keys: $(\ForwKey,\BackKey) \gets \CFPTP.\Gen(1^{\SecParam})$.
    \item Define the CRS string $\crs = (\ForwKey, \EncKey)$.
    \item If $\Simulator$ receives any queries to $\IFCrs$, return the CRS string $\crs = (\ForwKey, \EncKey)$.
\end{enumerate}

\item \parhead{Commit round}
\begin{enumerate}[nolistsep]
	\item Receive $(\sid, \CommitterId, \ReceiverId)$ from $\Environment$. Note that the committed bit $\CommittedBit$ is NOT received.
    \item Compute a claw:
    \begin{enumerate}[nolistsep]
        \item Sample $\Input_0\gets\Domain$.
        \item Compute $\Output \eqdef \CFPTP.\Forw_{0,\ForwKey}(\Input_0)$.
        \item Compute $\Input_1 \eqdef \CFPTP.\Back_{1,\BackKey}(\Output)$.
    \end{enumerate}
    \item Compute ciphertexts:
    \begin{enumerate}[nolistsep]
        \item Sample commitment randomness $\Rand_{0}$ and $\Rand_{1}$.
    	\item Compute $\Ct_{0} = \PKE.\Enc(\EncKey,\Input_{0}, \sid; \Rand_{0})$.
    	\item Compute $\Ct_{1} = \PKE.\Enc(\EncKey,\Input_{1}, \sid; \Rand_{1})$.
    \end{enumerate}
	\item Send the commitment $(\sid,\CommitterId,\ReceiverId,\Output, \Ct_0, \Ct_1)$ to $\IFCom$.
\end{enumerate}

\item \parhead{Open round}

\begin{enumerate}[nolistsep]
    \item Receive $(\OpenMsg,\sid,\CommitterId,\ReceiverId)$ from $\Environment$.
	\item Query the ideal functionality $\IFCom$ to receive the committed bit $\CommittedBit$.
    \item Send $(\CommittedBit, \Input_{\CommittedBit}, \Rand_{\CommittedBit})$ to $\IFCom$.
\end{enumerate}

\end{itemize}

\parhead{Case 2: Corrupted committer}

The simulator $\Simulator$ does the following:
\begin{itemize}
\item \parhead{Simulate $\IFCrs$}
\begin{enumerate}[nolistsep]
    \item Generate encryption keys: $(\EncKey, \DecKey) \gets \PKE.\Gen(1^{\SecParam})$.
    \item Generate CFPTP keys: $(\ForwKey,\BackKey) \gets \CFPTP.\Gen(1^{\SecParam})$.
    \item Define the CRS string $\crs = (\ForwKey, \EncKey)$.
    \item If $\Simulator$ receives any queries to $\IFCrs$, return the CRS string $\crs = (\ForwKey, \EncKey)$.
\end{enumerate}

\item \parhead{Commit round}
\begin{enumerate}[nolistsep]
    \item Receive $\Adversary$'s desired commitment string: $(\Output, \Ct_0, \Ct_1)$. Note that the committed bit $\CommittedBit$ is NOT received.
    \item Extract the committed bit:
    \begin{enumerate}[nolistsep]
        \item Decrypt $\Ct_0$ to get $\tilde{\Input} \eqdef \PKE.\Dec(\DecKey, \Ct_0)$.
        \item If $\tilde{\Input} = \CFPTP.\Back_0(\BackKey, \Output)$, set $\ExtBit = 0$. Otherwise, set $\ExtBit = 1$.
    \end{enumerate}
    \item Send $(\CommitMsg, \CommitterId, \ReceiverId, \ExtBit)$ to $\IFCom$.
\end{enumerate}

\item \parhead{Open round}
\begin{enumerate}[nolistsep]
    \item Receive $\Adversary$'s desired opening string: $(\AdvBit, \Input, \Rand)$.
	\item If $\ExtBit = \AdvBit$, $\Input = \CFPTP.\Back_{\AdvBit}(\BackKey, \Output)$, and $\Ct_{\AdvBit} = \PKE.\Enc(\EncKey, \Input; \Rand)$, send $(\OpenMsg, \CommitterId, \ReceiverId)$ to $\IFCom$. Otherwise, abort.
\end{enumerate}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\doclearpage
{\small{
\bibliographystyle{alpha}
\bibliography{refs}
}}

\end{document}
